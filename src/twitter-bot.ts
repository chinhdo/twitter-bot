import Twitter from 'twitter-lite';
import { Tweet } from './models';
import fs from 'fs';
require('dotenv').config();

// TODO: show user avatar next to tweet

class TwitterBot {
  private twitClient: Twitter;

  public constructor(twitClient?: Twitter) {
    this.twitClient = twitClient ||
      new Twitter({
        consumer_key: process.env.consumer_key as string,
        consumer_secret: process.env.consumer_secret as string,
        access_token_key: process.env.access_token_key,
        access_token_secret: process.env.access_token_secret
      });
  }

  async start() {
    const tweets = await this.findTweets();
    await this.genHtmlReport(tweets);
  }

  /** Find tweets to review */
  async findTweets(): Promise<Tweet[]> {
    const tweets: Tweet[] = [];

    let numTweetsFound = 0;
    const numTweetsToFind = 10;
    let maxId: string | undefined;
    while (numTweetsFound < numTweetsToFind) {
      const rateLimit = await this.getRateLimit();
      const searchTweetLimits = rateLimit.resources.search['/search/tweets'];
      this.log(`Search limits : ${JSON.stringify(searchTweetLimits)}`);

      if (searchTweetLimits.remaining < 5) {
        this.log(`Out of limits. Waiting a minute to retry later.`); // TODO: wait for exact duration needed
        await this.sleep(60000);
      }

      // Search
      const searchResult = await this.search('#100DaysOfCode', 100, maxId);
      this.log(`Got ${searchResult.statuses.length} statuses from search.`);

      // Find matching tweets
      let count = 0;      
      while (true) {
        const s = searchResult.statuses[count];
        const likes = parseInt(s.favorite_count);
        const followers = parseInt(s.user.followers_count);
        const userAdded = tweets.find((t) => s.user.screen_name === t.userScreenName);
        maxId = s.id_str;

        // Exclude tweets that are:
        // * retweets
        // * From users with more than 100
        // * Have more than than 10 likes
        // * A reply
        // * From a user already added to the list
        if (!(
            s.text.match(/^RT/i) || likes > 10 || followers > 100 || s.in_reply_to || userAdded)
          ) {
          numTweetsFound ++;
          this.log(`** ${numTweetsFound} - ${s.user.screen_name} ${s.id_str} likes=${s.favorite_count} followers=${followers} ` +
            `in_reply_to=${s.in_reply_to_status_id} created=${s.created_at}\n${s.text}\n`);

          const tweet = new Tweet();
          tweet.id = s.id_str;
          tweet.created = s.created_at;
          tweet.likes = likes;
          tweet.userScreenName = s.user.screen_name;
          tweet.userFollowers = followers;
          tweet.text = s.text;
          tweets.push(tweet);

          // TODO
          // // Like then sleep a little - don't want to like too quick and get in trouble with Twitter big brother
          // await this.like(s.id_str);
          // const sleepMs = 1000 + Math.floor(Math.random() * 5000); 
          // this.log(`Sleeping for ${sleepMs} ms.`);
          // await this.sleep(sleepMs);
        }

        count++;
        if (numTweetsFound >= numTweetsToFind || count >= searchResult.statuses.length) { break; }
      }

      await this.sleep(1000);
    }

    return tweets;
  }

  async getRateLimit(): Promise<any> {
    const rateLimits = await this.twitClient.get("application/rate_limit_status");
    return rateLimits;
  }

  /** Generate an HTML report of tweets to review */
  async genHtmlReport(tweets: Tweet[]): Promise<void> {
    let html = `
    <!doctype html>
    <html lang="en">
    <head>
      <meta charset="utf-8">
      <link href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" crossorigin="anonymous">
      <style>
      .tweet {
        font-size: 0.9em
      }
      .tweet a:link {
        text-decoration: none;
      }
    </style>
    </head>
    <body>
      <div class="container">
      <h1>Recommended tweets for the day</h1>
      <p>Generated by Chinh's TwitterBot</p>
    `;
    html += '<ul>';
    tweets.forEach(t => {
      html += `<li><a href="https://twitter.com/${t.userScreenName}">${t.userScreenName}</a> - <a href="https://twitter.com/${t.userScreenName}/status/${t.id}" class="tweet" target="_blank">${t.text}</a></li>`;
    });
    html += '</ul>';
    html += '</div></body></html>';

    const path = 'lib/report.html';
    fs.writeFileSync(path, html, {encoding: 'utf8'});
  }

  async search(query: string, count: number = 1, maxId: string = ''): Promise<any> {
    const result = await this.twitClient.get("search/tweets",
      { q: encodeURI(query), count: count, max_id: maxId ? maxId : undefined});
    return result;
  }

  async like(tweetId: string): Promise<void> {
    try {
      await this.twitClient.post("favorites/create", { id: tweetId });
    }
    catch (error) {
      console.error(error);
    }
  }

  private async sleep(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  private log(msg: any) {
    console.log(msg);
  }
}

export default TwitterBot;